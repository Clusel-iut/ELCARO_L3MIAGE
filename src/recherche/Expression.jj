/**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */options{  static = true;}PARSER_BEGIN(Expression)package recherche;

abstract class Expr {
  public abstract int eval();
}
class Plus extends Expr {
  private Expr op1, op2;
  public Plus(Expr op1, Expr op2) {this.op1=op1; this.op2=op2; }
  public int eval() {  return op1.eval()+op2.eval(); }
}
class Mult extends Expr {
  private Expr op1, op2;
  public Mult(Expr op1, Expr op2) {this.op1=op1; this.op2=op2; }
  public int eval() {  return op1.eval()*op2.eval(); }
}
class Cste extends Expr {
  private int v;
  public Cste(int v) {this.v=v; }
  public int eval() {  return v; }
}
enum Operateur { PLUS { }, MOINS, MULT, DIV;
public Expr constr(Expr e1, Expr e2); }

public class Expression{  public static void main(String args []) throws ParseException  {    Expression parser = new Expression(System.in);    while (true)    {      System.out.println("Reading from standard input...");      System.out.print("Enter an expression like \"1+(2+3)*4;\" :");      try      {		System.out.println(parser.sum().eval());      }      catch (Exception e)      {        System.out.println("NOK.");        System.out.println(e.getMessage());        Expression.ReInit(System.in);      }      catch (Error e)      {        System.out.println("Oops.");        System.out.println(e.getMessage());        break;      }    }  }}PARSER_END(Expression)SKIP :{  " "| "\r"| "\t"| "\n"}TOKEN : /* OPERATORS */{  < PLUS : "+" >| < MINUS : "-" >| < MULTIPLY : "*" >| < DIVIDE : "/" >}TOKEN :{  < CONSTANT : (< DIGIT >)+ >| < #DIGIT : [ "0"-"9" ] >}int one_line() :{}{  sum() ";"  {    return 0;  }| ";"  {    return 1;  }}Expr sum() :{Expr e1, e2;Operateur op;}{  e1=term()((< PLUS > { op = Operateur.PLUS;}| < MINUS >{ op = Operateur.MOINS;})e2=term(){e1=new Plus(e1,e2); })*{  return e1; }}Expr term() :{Expr e1, e2;}{  e1=unary() (( < MULTIPLY >| < DIVIDE >)e2=unary() {e1=new Mult(e1,e2); })* {  return e1; }}Expr unary() :{Expr e;}{  < MINUS > e=element(){  return new Cste(-e.eval()); }| e=element(){  return e; }}Expr element() :{Token t; Expr e;}{  t=< CONSTANT > {return new Cste(Integer.parseInt(t.image)); }| "(" e=sum() ")" {  return e; }}
